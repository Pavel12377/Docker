Для чего нужны контейнеры
Как я познакомился с докером.
В одном из моих педыдущий проектов было требование настроить сквозной стек, включающий различные технологии:

веб-сервер, использующий node js
БД, такую как mongoDB
система обмена сообщениями Redis
оркестрация с помощью Ansible
Из-за того, что компоненты были разнородные мы столкнулись с множеством проблем при разработке и поддержке этого приложения.

Во-первых, их совместимость с базовой операционной системой. Мы должны были обеспечить чтобы все эти сервисы были совместимы с версиями ОС, которую мы планировали использовать. Получалось что некоторые версии этих компонентов были несовместимы с ОС. Нам приходилось останавливаться и находить другую ОС совместимую со всеми этими службами.

Во-вторых, нам нужно было быть уверенными в совместимости сервисов и библиотек с зависомостями ОС. У нас были проблемы, когда для одной службы нужна была одна версия зависимой библиотеки, а для другой службы - другая.

Со временем архитектура нашего приложения менялась. Нам пришлось обновить компоненты до более новой версии. Поменять БД и т.д. Каждый раз, когда что-то менялось, нам приходилось проходить один и тот же процесс проверки совместимости между этими различными компонентами и базовой инфраструктурой.

Эта проблема с матрицой совместимости обычно называется "матрицой из ада".

Далее каждый раз, когда у нас появлялся новый разработчик, нам было действительно сложно создать новую среду. Новым разработчикам приходилось следовать большому набору инструкций и запускать сотни команд, чтобы наконец настроить свою среду. Они должны были убедиться, что используют правильную ОС, правильную версию каждой из компонент. И каждый разработчик должен был настраивать все это каждый раз самостоятельно.

У нас также были разные среды для разработки, тестирования и продакшена.

Одному разработчику было удобно использовать одну ОС, другим - другую. Поэтому мы не могли гарантировать, что созданное приложение будет работать одинаково в разных средах.

И так все это значительно усложнило нам жизнь в разработке, создании и доставке приложения.

Нам нужно было что-то, что могло помочь нам в решении проблем с совместимостью. Что-то что позволит нам изменять или заменять эти компоненты не затрагивая другие компоненты и даже изменять базовые ОС по мере необходимости.

И этот поиск привел меня к Docker. В докер я мог запускать каждый компонент отдельно с своими собственными библиотеками и зависимостями от одной и той же виртуальной машины и ОС. Все упаковывалось в отдельное окружение - контейнер.

Нам нужно было один раз собрать конфигурацию докер и теперь все наши разработчики могли начать работу с простой команды запуска докера.

Не зависимо от того, какую ОС они используют все, что им нужно было сделать - это убедиться, что и их системах установлен докер.

Так что же такое контейнер?
Контейнер - это полностью изолированные среды.

В них свои процессы и службы. Собственные сетевые интерфейсы, собстевнные средства монтирования.

Это похоже на виртуальные машины. За исключением того, что все они используют одно ядро ОС.

Мы немного рассмотрим, что это значит.

Также важно отметить, что контейнеры не новость в докер. Контейнеры существовали около 10 лет.

Рассмотрим некоторые из типов контейнера.

Докер использует контейнеры lxc, настроить эти контейнерные среды сложно поскольку они очень низкого уровня.

Именно здесь докер предлагает инструменты более высокого уровня с несколькими мощными функциями, которые делают его действительно легким для таких конечных пользователей как мы.

Чтобы понять как работает докер давай сначала вернемся к некоторым основным концепциям ОС.

Если ты посмотришь на такие ОС как убунта, федора или центос, все они состоят из двух вещей: ядро ОС и ПО. Ядро ОС отвечает за взаимодействие с базовым оборудованием. В то время как ядро ОС остается тем же, в данном случае Линукс, слой ПО, расположенный выше, отличается для разных ОС. Это ПО может состоять из интерфейсов пользователя, драйверов, компиляторов, файловых менеджеров, инструментов разработчика и т.д.

В итоге у нас есть общее ядро Линукс, используемое во всех ОС, и некоторое настраиваемое ПО, которое отличает одну ОС от другой.

Ранее мы говорили, что контейнеры докер совместно используют базовое ядро. Что на самом деле означает совместное использование ядра?

Допустим у нас есть система с ОС убунту с установленным на ней докер. Докер может запускать поверх себя любую версию ОС, если все они основаны на одном ядре. В данном случае Линукс. Если базовой ОС является убунту, докер может запускать контейнер на основе другого дистрибутива, например дебиан, федора, сьюс или центос.

В каждом докер контейнере есть только дополнительное ПО, которое делает ОС разными. И докер использует базовое ядро своего хоста, которое работает со всеми вышеперечисленными ОС.

А какая ОС не имеет такого же ядра? Windows. И поэтому ты не сможешь запустить контейнер на базе Виндовс на докер хосте с ОС Линукс. Для этого нам потребуется докер на сервере Виндовс.

Ты спросишь: разве это не недостаток? Невозможно запустить другое ядро в ОС. Ответ: нет. Потому что в отличие от гипервизоров, докер не предназначен для виртуализации и запуска различных ОС и ядер на одном оборудовании.

Основное назначение докер - контейнеризация приложений, а также их отправка и запуск.

Это подводит нас к различиям между виртуальными машинами и контейнерами. Вещи, которыми занимаются те, кто занимается виртуализацией.

Различиям между виртуальными машинами и контейнерами
VM	Docker
Виртуальная машина: приложение, библиотеки, зависимости, операционная система	Контейнер: приложение, библиотека, зависимости
Гипервизор	Docker
Операционная система	Операционная система
Аппаратная инфраструктура	Аппаратная инфраструктура
Как видишь справа в случае с докером у нас есть базовая аппаратная инфраструктура, затем ОС и докер, устновленный на ОС. Докер может управлять контейнерами, которые работают с библиотеками и зависимостями сами в одиночку.

В случае виртуальной машины, у нас есть ОС на базовом оборудовании. Затем гипервизор такой как esx или какая-то другая виртуализация. А затем виртуальная машина.

Как видишь у каждой виртуальной машины внутри своя ОС, толстый слой зависимостей, а затем приложение. Эти накладные расходы приводят к более высокому использованию вычислительных ресурсов. Поскольку приходится крутить несколько виртуальных ОС с их ядрами.

Также виртуальные машины потребляют больше дискового пространства поскольку каждая виртуальная машина тяжелая и обычно имеет размер в гигабайтах. Тогда как контейнеры докер легковесны и обычно имеют размер в мегабайтах.

Это позволяет докер контейнерам загружаться быстрее, обычно за считанные секунды. Тогда как виртуальные машины грузятся по несколько минут, так как для этого требуется загрузка всей ОС.

Также важно отметить, что докер имеет меньшую изоляцию, поскольку больше ресурсов используется совместно между контейнерами, например ядро. Тогда как виртуальные машины полностью изолированы друг от друга.

В случае виртуальной машины у нас могут быть разные типы ОС такие как Линукс или Виндовс на основе одного и того же гипервизора. Тогда как на докер хосте это невозможно.

Так что же выбрать: контейнеры или виртуальные машины?

Я скажу так: выбери лучшее от обеих технологий. Ты можешь работать с контейнерами на виртуальных хостах докера. Виртуализация даст тебе возможность легковводить, выводить из эксплуатации или перемещать большое количество докер хостов. А контейнеризация - быстро масштабироваться и легко обновляться.

С таким подходом тебе не нужно создавать определенную виртуальную машину под конкретное приложение. Теперь это задача виртуальной машины - запускать контейнеры и делать это хорошо. И эта эластичность и гибкость отлично подходит к облачным вычислениям.

В облаке сегодня ты можешь иметь тысячи контейнеров на сотне докер хостов, а завтра легко вырасти или уменьшится при необходимости.

Это были ключевые различия между ними.

Как сделать все это руками?
На сегодняшний день доступно много контейнерных версий приложений. Продукты большинства организаций хранятся в контейнерах и могут быть получены из общедоступного docker registry с названием dockerhub.

Например, ты можешь найти образ наиболее распространенных ОС, БД и других сервисов и инструментов.

Как только ты определился с образом, тебе нужно установить докер на свой хост.

Для запуска приложения просто напиши команду docker run с именем образа.

docker run ansible
В этом случае запуск команды docker run ansible запустит экземпляр ansible на докер хосте.

Точно также запускаются экземпляры mongodb, redis, nodejs с помощью команды docker run.

Когда запускаешь экземпляр nodejs просто укажи расположение репозитория нода.

docker run mongodb
docker run redis
docker run node
Если тебе нужно несколько экземпляров веб-службы, просто создай требуемое количество экземпляров и настрой какой-либо балансировщик нагрузки на входе.

В случае отказа одного из экземпляров, просто уничтож этот экземпляр и зупусти новый инстанс.

Существуют и другие решения для обработки таких случаев, их мы рассмотрим позже в ходе этого курса.

Разница мужду образами и контейнерами.
Мы говорили об образах и контейнерах. Давай поймем разницу между ними.

Образ - это пакет или шаблон. Анологичный шаблону виртуальной машины, с которыми ты мб работал в среде виртуализации. Он используется для создания одного или нескольких контейнеров. Докер запускает экземпляр образов, которые изолированы, имеют свои собственные среды и процессы.

Как мы видели раньше, многи продукты уже докерезированы. Если ты не можешь найти то, что тебе нужно, ты можешь создать образ самостоятельно. Отправить его в репозиторий в докерхаб и сделать его доступным для всех.

Если посмотреть традиционно, то приложение разрабатывают разработчики, потом передают апстриму для развертывания и управления в производственных средах. Они делают это предоставляя набор инструкций таких как информация о том, как должны быть устновлены хосты, какие предварительные условия должны быть соблюдены и как должны быть настроены зависимости.

Команда ops использует это руководство для настройки приложения. Поскольку команда ops не разрабатывала приложение самостоятельно, они борются с его настройкой. Когда они сталкиваются с проблемой, то начинают дергать разработчиков. С докер основная часть работы, связанная с понятием инфраструктуры, теперь находится в руках разработчиков в виде докерфайла. Руководство, ранее созданное разработчиками для настройки инфраструктуры, теперь просто ложится в докер файл для создания образа приложения - этот образ теперь будет работать на любой контейнер на платформе и гарантированно будет работать везде одинаково. Таким образом, команда оперирования теперь может просто использовать образ для развертывания приложения.

Поскольку образ работал, когда разработчик создал его, а другие операции не изменяют образ, он продолжит работать таким же образом при развертывании в производственной среде.